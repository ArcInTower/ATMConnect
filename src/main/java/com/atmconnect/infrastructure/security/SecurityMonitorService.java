package com.atmconnect.infrastructure.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

@Service
@Slf4j
public class SecurityMonitorService implements HealthIndicator {
    
    private final Map<String, SecurityEvent> securityEvents = new ConcurrentHashMap<>();
    private final Map<String, AtomicInteger> failedAttempts = new ConcurrentHashMap<>();
    private final Map<String, Long> blockedIPs = new ConcurrentHashMap<>();
    private final AtomicLong totalSecurityEvents = new AtomicLong(0);
    private final AtomicLong criticalAlerts = new AtomicLong(0);
    private final ScheduledExecutorService monitorExecutor = Executors.newScheduledThreadPool(2);
    
    private static final int MAX_FAILED_ATTEMPTS = 5;
    private static final long BLOCK_DURATION_MINUTES = 30;
    private static final int MAX_EVENTS_PER_HOUR = 100;
    
    public enum SecurityEventType {\n        AUTHENTICATION_FAILURE,\n        RATE_LIMIT_EXCEEDED,\n        MALICIOUS_INPUT_DETECTED,\n        UNAUTHORIZED_ACCESS_ATTEMPT,\n        TOKEN_MANIPULATION,\n        SUSPICIOUS_TRANSACTION_PATTERN,\n        DEVICE_FINGERPRINT_MISMATCH,\n        CERTIFICATE_VALIDATION_FAILURE,\n        ENCRYPTION_FAILURE,\n        SESSION_HIJACK_ATTEMPT\n    }\n    \n    public enum SecurityLevel {\n        LOW(1),\n        MEDIUM(2),\n        HIGH(3),\n        CRITICAL(4);\n        \n        private final int value;\n        \n        SecurityLevel(int value) {\n            this.value = value;\n        }\n        \n        public int getValue() {\n            return value;\n        }\n    }\n    \n    private static class SecurityEvent {\n        final SecurityEventType type;\n        final SecurityLevel level;\n        final String source;\n        final String details;\n        final long timestamp;\n        final Map<String, Object> metadata;\n        \n        SecurityEvent(SecurityEventType type, SecurityLevel level, String source, \n                     String details, Map<String, Object> metadata) {\n            this.type = type;\n            this.level = level;\n            this.source = source;\n            this.details = details;\n            this.timestamp = Instant.now().getEpochSecond();\n            this.metadata = metadata != null ? new HashMap<>(metadata) : new HashMap<>();\n        }\n    }\n    \n    public SecurityMonitorService() {\n        startMonitoring();\n    }\n    \n    private void startMonitoring() {\n        // Clean up old events every hour\n        monitorExecutor.scheduleAtFixedRate(this::cleanupOldEvents, 1, 1, TimeUnit.HOURS);\n        \n        // Generate security reports every 15 minutes\n        monitorExecutor.scheduleAtFixedRate(this::generateSecurityReport, 15, 15, TimeUnit.MINUTES);\n        \n        // Check for suspicious patterns every 5 minutes\n        monitorExecutor.scheduleAtFixedRate(this::detectSuspiciousPatterns, 5, 5, TimeUnit.MINUTES);\n    }\n    \n    public void recordSecurityEvent(SecurityEventType type, SecurityLevel level, \n                                   String source, String details) {\n        recordSecurityEvent(type, level, source, details, null);\n    }\n    \n    public void recordSecurityEvent(SecurityEventType type, SecurityLevel level, \n                                   String source, String details, Map<String, Object> metadata) {\n        String eventId = UUID.randomUUID().toString();\n        SecurityEvent event = new SecurityEvent(type, level, source, details, metadata);\n        \n        securityEvents.put(eventId, event);\n        totalSecurityEvents.incrementAndGet();\n        \n        if (level == SecurityLevel.CRITICAL) {\n            criticalAlerts.incrementAndGet();\n            triggerCriticalAlert(event);\n        }\n        \n        // Log security event\n        log.warn(\"Security Event [{}]: {} - {} from {} - {}\", \n            level, type, details, source, eventId);\n        \n        // Handle specific event types\n        handleSpecificEvent(type, source);\n    }\n    \n    public void recordAuthenticationFailure(String source, String customerId, String reason) {\n        Map<String, Object> metadata = new HashMap<>();\n        metadata.put(\"customerId\", customerId);\n        metadata.put(\"reason\", reason);\n        metadata.put(\"userAgent\", getCurrentUserAgent());\n        \n        recordSecurityEvent(SecurityEventType.AUTHENTICATION_FAILURE, \n                          SecurityLevel.MEDIUM, source, \n                          \"Authentication failed for customer\", metadata);\n        \n        // Track failed attempts\n        int attempts = failedAttempts.computeIfAbsent(source, k -> new AtomicInteger(0))\n                                   .incrementAndGet();\n        \n        if (attempts >= MAX_FAILED_ATTEMPTS) {\n            blockIP(source, \"Too many failed authentication attempts\");\n        }\n    }\n    \n    public void recordSuspiciousTransaction(String accountId, String transactionDetails) {\n        Map<String, Object> metadata = new HashMap<>();\n        metadata.put(\"accountId\", accountId);\n        metadata.put(\"timestamp\", Instant.now().toString());\n        \n        recordSecurityEvent(SecurityEventType.SUSPICIOUS_TRANSACTION_PATTERN,\n                          SecurityLevel.HIGH, accountId, transactionDetails, metadata);\n    }\n    \n    public boolean isIPBlocked(String ipAddress) {\n        Long blockTime = blockedIPs.get(ipAddress);\n        if (blockTime == null) {\n            return false;\n        }\n        \n        long now = Instant.now().getEpochSecond();\n        if (now - blockTime > BLOCK_DURATION_MINUTES * 60) {\n            blockedIPs.remove(ipAddress);\n            failedAttempts.remove(ipAddress);\n            return false;\n        }\n        \n        return true;\n    }\n    \n    public void blockIP(String ipAddress, String reason) {\n        blockedIPs.put(ipAddress, Instant.now().getEpochSecond());\n        \n        recordSecurityEvent(SecurityEventType.UNAUTHORIZED_ACCESS_ATTEMPT,\n                          SecurityLevel.HIGH, ipAddress, \n                          \"IP blocked: \" + reason, null);\n        \n        log.error(\"IP Address blocked: {} - Reason: {}\", ipAddress, reason);\n    }\n    \n    public void unblockIP(String ipAddress) {\n        blockedIPs.remove(ipAddress);\n        failedAttempts.remove(ipAddress);\n        \n        log.info(\"IP Address unblocked: {}\", ipAddress);\n    }\n    \n    public List<SecurityEvent> getRecentEvents(int limit) {\n        return securityEvents.values().stream()\n                .sorted((e1, e2) -> Long.compare(e2.timestamp, e1.timestamp))\n                .limit(limit)\n                .toList();\n    }\n    \n    public Map<SecurityEventType, Long> getEventStatistics() {\n        Map<SecurityEventType, Long> stats = new HashMap<>();\n        \n        for (SecurityEventType type : SecurityEventType.values()) {\n            long count = securityEvents.values().stream()\n                    .filter(event -> event.type == type)\n                    .count();\n            stats.put(type, count);\n        }\n        \n        return stats;\n    }\n    \n    @Override\n    public Health health() {\n        long now = Instant.now().getEpochSecond();\n        long oneHourAgo = now - 3600;\n        \n        long recentEvents = securityEvents.values().stream()\n                .filter(event -> event.timestamp > oneHourAgo)\n                .count();\n        \n        long recentCriticalEvents = securityEvents.values().stream()\n                .filter(event -> event.timestamp > oneHourAgo && \n                              event.level == SecurityLevel.CRITICAL)\n                .count();\n        \n        Health.Builder builder = Health.up()\n                .withDetail(\"totalSecurityEvents\", totalSecurityEvents.get())\n                .withDetail(\"recentEventsLastHour\", recentEvents)\n                .withDetail(\"criticalAlertsTotal\", criticalAlerts.get())\n                .withDetail(\"recentCriticalEvents\", recentCriticalEvents)\n                .withDetail(\"blockedIPs\", blockedIPs.size())\n                .withDetail(\"activeFailedAttempts\", failedAttempts.size());\n        \n        if (recentCriticalEvents > 5 || recentEvents > MAX_EVENTS_PER_HOUR) {\n            builder.down().withDetail(\"reason\", \"High security event rate detected\");\n        }\n        \n        return builder.build();\n    }\n    \n    private void handleSpecificEvent(SecurityEventType type, String source) {\n        switch (type) {\n            case RATE_LIMIT_EXCEEDED:\n                // Extend monitoring for this source\n                break;\n            case MALICIOUS_INPUT_DETECTED:\n                // Consider temporary blocking\n                int attempts = failedAttempts.computeIfAbsent(source, k -> new AtomicInteger(0))\n                                           .incrementAndGet();\n                if (attempts >= 3) {\n                    blockIP(source, \"Multiple malicious input attempts\");\n                }\n                break;\n            case TOKEN_MANIPULATION:\n                // Immediate investigation required\n                triggerSecurityAlert(\"Token manipulation detected from: \" + source);\n                break;\n            default:\n                // Default handling\n                break;\n        }\n    }\n    \n    private void triggerCriticalAlert(SecurityEvent event) {\n        log.error(\"CRITICAL SECURITY ALERT: {} from {} - {}\", \n            event.type, event.source, event.details);\n        \n        // In production, this would:\n        // 1. Send alerts to security team\n        // 2. Trigger automated response\n        // 3. Create incident tickets\n        // 4. Notify compliance team\n    }\n    \n    private void triggerSecurityAlert(String message) {\n        log.error(\"SECURITY ALERT: {}\", message);\n        \n        // In production: send to SIEM, security team notifications, etc.\n    }\n    \n    private void cleanupOldEvents() {\n        long cutoff = Instant.now().minus(24, ChronoUnit.HOURS).getEpochSecond();\n        \n        securityEvents.entrySet().removeIf(entry -> entry.getValue().timestamp < cutoff);\n        \n        // Clean up old blocked IPs\n        long now = Instant.now().getEpochSecond();\n        blockedIPs.entrySet().removeIf(entry -> \n            now - entry.getValue() > BLOCK_DURATION_MINUTES * 60);\n    }\n    \n    private void generateSecurityReport() {\n        long now = Instant.now().getEpochSecond();\n        long oneHourAgo = now - 3600;\n        \n        long recentEvents = securityEvents.values().stream()\n                .filter(event -> event.timestamp > oneHourAgo)\n                .count();\n        \n        if (recentEvents > 0) {\n            log.info(\"Security Report: {} events in last hour, {} total events, {} blocked IPs\",\n                recentEvents, totalSecurityEvents.get(), blockedIPs.size());\n        }\n    }\n    \n    private void detectSuspiciousPatterns() {\n        // Analyze patterns in security events\n        // This is a simplified example - production would have more sophisticated analysis\n        \n        Map<String, Long> sourceFrequency = new HashMap<>();\n        long now = Instant.now().getEpochSecond();\n        long fiveMinutesAgo = now - 300;\n        \n        securityEvents.values().stream()\n                .filter(event -> event.timestamp > fiveMinutesAgo)\n                .forEach(event -> sourceFrequency.merge(event.source, 1L, Long::sum));\n        \n        sourceFrequency.entrySet().stream()\n                .filter(entry -> entry.getValue() > 10) // More than 10 events in 5 minutes\n                .forEach(entry -> {\n                    if (!isIPBlocked(entry.getKey())) {\n                        blockIP(entry.getKey(), \"Suspicious activity pattern detected\");\n                    }\n                });\n    }\n    \n    private String getCurrentUserAgent() {\n        // In a real implementation, this would get the user agent from the request context\n        return \"Unknown\";\n    }\n    \n    public void shutdown() {\n        if (monitorExecutor != null && !monitorExecutor.isShutdown()) {\n            monitorExecutor.shutdown();\n            try {\n                if (!monitorExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n                    monitorExecutor.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                monitorExecutor.shutdownNow();\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}